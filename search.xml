<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>nginx服务器配置ssl</title>
    <url>/2021/10/20/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEssl/</url>
    <content><![CDATA[<p>这里暂只讲解nginx配置ssl过程,如何获取ssl证书请自行百度</p>
<span id="more"></span>

<h3 id="拷贝证书文件"><a href="#拷贝证书文件" class="headerlink" title="拷贝证书文件"></a>拷贝证书文件</h3><p>将获取到的两个文件(.pem和.key)拷贝到服务器上<br>建议在网站根目录新建一个名为cert的目录来存放证书文件</p>
<h3 id="更改nginx配置文件"><a href="#更改nginx配置文件" class="headerlink" title="更改nginx配置文件"></a>更改nginx配置文件</h3><p>找到nginx配置文件nginx.conf,不同主机可能路径不一致,我的是在/etc/nginx下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx</span><br><span class="line">vi nginx.conf</span><br></pre></td></tr></table></figure>
<p>在http{ }里面添加如下内容（有的文件里有此内容，默认是注释掉的，根据需要取消注释）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen       443 ssl http2;</span><br><span class="line">       listen       [::]:443 ssl http2;</span><br><span class="line">       server_name  www.xxxxxx.xxx;  <span class="comment">#证书绑定的域名</span></span><br><span class="line">       root         xxxxxxxx;   <span class="comment">#网站根目录路径，根据自己的网站位置进行修改</span></span><br><span class="line"></span><br><span class="line">       ssl_certificate <span class="string">&quot;xxxxx.pem&quot;</span>;    <span class="comment">#这里替换为cert目录里的.pem文件，注意路径的使用</span></span><br><span class="line">       ssl_certificate_key <span class="string">&quot;xxxxxx.key&quot;</span>;  <span class="comment">#这里替换为cert目录里的.key文件，注意路径的使用</span></span><br><span class="line">       ssl_session_cache shared:SSL:1m;</span><br><span class="line">       ssl_session_timeout  10m;</span><br><span class="line">       ssl_ciphers HIGH:!aNULL:!MD5;    <span class="comment">#加密套件类型</span></span><br><span class="line">       ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">       ssl_protocols TLSv1 TLSv1.1 TLSv1.2;     <span class="comment">#TSL协议类型</span></span><br><span class="line">       <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">       include /etc/nginx/default.d/*.conf;    <span class="comment">#这里无需修改</span></span><br><span class="line">	<span class="comment"># 以下内容为非必选项</span></span><br><span class="line">       error_page 404 /404.html;</span><br><span class="line">           location = /40x.html &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       error_page 500 502 503 504 /50x.html;</span><br><span class="line">           location = /50x.html &#123;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">#注意大括号一定要一一对应，否则可能会无法启用nginx服务</span></span><br></pre></td></tr></table></figure>

<h3 id="HTTP重定向（可选）"><a href="#HTTP重定向（可选）" class="headerlink" title="HTTP重定向（可选）"></a>HTTP重定向（可选）</h3><p>该设置可以使HTTP请求自动跳转HTTPS<br>在nginx.conf文件里找到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	listen     80;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改server_name,同上<br>再加入如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rewrite ^(.*)$ https://$host<span class="variable">$1</span>; <span class="comment">#将所有HTTP请求通过rewrite指令重定向到HTTPS。</span></span><br></pre></td></tr></table></figure>
<h3 id="重启nginx服务"><a href="#重启nginx服务" class="headerlink" title="重启nginx服务"></a>重启nginx服务</h3><h4 id="方法1-进入nginx的可执行目录"><a href="#方法1-进入nginx的可执行目录" class="headerlink" title="方法1.进入nginx的可执行目录"></a>方法1.进入nginx的可执行目录</h4><p>通过nginx可执行文件重新加载配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/sbin  <span class="comment">#进入Nginx服务的可执行目录。</span></span><br><span class="line">./nginx -s reload  <span class="comment">#重新载入配置文件。</span></span><br></pre></td></tr></table></figure>
<h4 id="方法2-使用系统重启命令"><a href="#方法2-使用系统重启命令" class="headerlink" title="方法2.使用系统重启命令"></a>方法2.使用系统重启命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx.service</span><br></pre></td></tr></table></figure>

<h3 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h3><p>在浏览器输 https://你的域名 ，如图位置出现一把锁的图案便大功告成</p>
<p><img src="/images/success.png" alt="配置成功示例图"></p>
]]></content>
      <categories>
        <category>服务器配置</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>xdd相关依赖安装</title>
    <url>/2021/10/17/xdd%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="node-js-及xdd-相关依赖安装"><a href="#node-js-及xdd-相关依赖安装" class="headerlink" title="node.js 及xdd 相关依赖安装"></a>node.js 及xdd 相关依赖安装</h1><h2 id="1-下载node压缩包-同样安装在usr-local目录"><a href="#1-下载node压缩包-同样安装在usr-local目录" class="headerlink" title="1.下载node压缩包 同样安装在usr/local目录"></a>1.下载node压缩包 同样安装在usr/local目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>  &amp;&amp; wget https://nodejs.org/dist/v14.17.5/node-v14.17.5-linux-x64.tar.xz</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h2 id="2-解压node压缩包"><a href="#2-解压node压缩包" class="headerlink" title="2.解压node压缩包"></a>2.解压node压缩包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xz -dk node-v14.17.5-linux-x64.tar.xz  &amp;&amp; tar -xvf node-v14.17.5-linux-x64.tar</span><br></pre></td></tr></table></figure>



<h2 id="3-node-js环境配置"><a href="#3-node-js环境配置" class="headerlink" title="3.node.js环境配置"></a>3.node.js环境配置</h2><h3 id="1-进入配置文件"><a href="#1-进入配置文件" class="headerlink" title="(1).进入配置文件"></a>(1).进入配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure>



<h3 id="2-按键-i-进入插入编辑模式，在文件的最后面新行添加以下三行代码："><a href="#2-按键-i-进入插入编辑模式，在文件的最后面新行添加以下三行代码：" class="headerlink" title="(2).按键 i 进入插入编辑模式，在文件的最后面新行添加以下三行代码："></a>(2).按键 i 进入插入编辑模式，在文件的最后面新行添加以下三行代码：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NODE_HOME=/usr/<span class="built_in">local</span>/node-v14.17.5-linux-x64</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$NODE_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> NODE_PATH=<span class="variable">$NODE_HOME</span>/lib/node_modules</span><br></pre></td></tr></table></figure>



<h3 id="3-编辑完成后按键盘上的ESC键-输入-wq-保存退出输入"><a href="#3-编辑完成后按键盘上的ESC键-输入-wq-保存退出输入" class="headerlink" title="(3)编辑完成后按键盘上的ESC键,输入:wq 保存退出输入"></a>(3)编辑完成后按键盘上的ESC键,输入:wq 保存退出输入</h3><h3 id="4-生效配置文件"><a href="#4-生效配置文件" class="headerlink" title="(4)生效配置文件"></a>(4)生效配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h2 id="4-检查是否安装成功"><a href="#4-检查是否安装成功" class="headerlink" title="4.检查是否安装成功"></a>4.检查是否安装成功</h2><p>查看node版本 node -v<br>查询结果 V14.17.5<br>查看nmp版本 npm -v<br>查询结果 V6.14.xx</p>
<p>然后通过npm安装got、tough-cookie、crypto-js依赖 挨个跑 不要回root下，回去的话②和③记得 cd xdd/scripts目录<br>plus版把所有命令里的cd xdd 改为cd xdd-plus 即可<br>①.安装got</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> xdd-plus  &amp;&amp;  npm install got</span><br></pre></td></tr></table></figure>

<p>②.安装tough-cookie</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> scripts &amp;&amp; npm install png-js crypto-js download got http-server request tough-cookie tunnel ws</span><br></pre></td></tr></table></figure>

<p>③.安装crypto-js</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install crypto-js</span><br></pre></td></tr></table></figure>

<p>最后说一下 这个版本资产查询 需要在xdd/scripts目录下放Faker仓库的jd_bean_change_new.js<br>拉去命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> xdd-plus/scripts  &amp;&amp; wget https://cdn.jsdelivr.net/gh/muzikeji/mzkj@master/20210908/jd_bean_change_new.js</span><br></pre></td></tr></table></figure>

<p>wskey自动转换文件拉去</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &amp;&amp;  <span class="built_in">cd</span> xdd-plus/scripts &amp;&amp; wget https://cdn.jsdelivr.net/gh/muzikeji/mzkj@master/20210908/wspt.py</span><br></pre></td></tr></table></figure>

<p>新增 wskey自动更新ptkey功能 需要用户提供wskey 添加后台<br>同时需要安装pip</p>
<h1 id="Python-pip-安装"><a href="#Python-pip-安装" class="headerlink" title="Python pip 安装"></a>Python pip 安装</h1><p>pip 是 Python 包管理工具，该工具提供了对Python 包的查找、下载、安装、卸载的功能。<br>目前如果你在 python.org 下载最新版本的安装包，则是已经自带了该工具。<br>pip 官网：<a href="https://pypi.org/project/pip/">https://pypi.org/project/pip/</a><br>你可以通过以下命令来判断是否已安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip --version     <span class="comment"># Python2.x 版本命令</span></span><br><span class="line">pip3 --version    <span class="comment"># Python3.x 版本命令</span></span><br></pre></td></tr></table></figure>

<p>如果你还未安装，则可以使用以下方法来安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py   <span class="comment"># 下载安装脚本</span></span><br><span class="line"> sudo python get-pip.py    <span class="comment"># 2.x运行安装脚本</span></span><br><span class="line"> sudo python3 get-pip.py    <span class="comment"># 3.x运行安装脚本。</span></span><br></pre></td></tr></table></figure>

<p>centos使用下面命令pip</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install python-pip</span><br></pre></td></tr></table></figure>

<p>一般情况 pip 对应的是 Python 2.7，pip3 对应的是 Python 3.x。注意：用哪个版本的 Python 运行安装脚本，pip 就被关联到哪个版本<br>部分 Linux 发行版可直接用包管理器安装 pip，如 Debian 和 Ubuntu：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-pip</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>青龙面板</category>
      </categories>
      <tags>
        <tag>xdd-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2021/11/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h2><p>程序=数据结构+算法</p>
<h3 id="数据结构的概念"><a href="#数据结构的概念" class="headerlink" title="数据结构的概念"></a>数据结构的概念</h3><p>数据：客观描述事物的数值、字符等及能被输入到计算机中且能被处理的各种符号集合。<br>数据元素：组成数据的基本单位，是数据集合的个体。一个元素由多个数据项组成，数据项是数据的最小单位。<br>数据对象：性质相同的数据元素的集合<br>数据结构：相互之间存在一种或多种特定关系的数据元素集合。<br>数据类型<br>数据抽象与抽象数据类型</p>
<h3 id="数据结构的内容"><a href="#数据结构的内容" class="headerlink" title="数据结构的内容"></a>数据结构的内容</h3><p>数据结构的内容可归纳为三个部分：逻辑结构、存储结构、运算集合<br>数据的逻辑结构<br><img src="/images/image-20211125205558173.png" alt="image-20211125205558173"></p>
<p>数据的存储结构：顺序存储、链式存储</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法：解决问题的一系列操作步骤的集合<br>算法的特性：</p>
<ul>
<li><strong>有穷性</strong>：有限次的循环，不会产生死循环</li>
<li><strong>确定性</strong>：含义明确，不能有歧义</li>
<li><strong>可行性</strong>：算法的每一步必须是可行的</li>
<li><strong>有输入</strong></li>
<li><strong>有输出</strong></li>
</ul>
<p>算法的评价标准：</p>
<ul>
<li><strong>正确性</strong></li>
<li><strong>可读性</strong></li>
<li><strong>健壮性</strong>（鲁棒性）</li>
<li><strong>高效率与低存储</strong></li>
</ul>
<p><strong>时间复杂度</strong>：算法基本操作（关键语句）重复执行的次数<br><strong>空间复杂度</strong>：算法执行时所需存储空间的度量</p>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表：元素之间具有“一对一”的前驱后继关系<br>基本操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">InitList ( );                <span class="comment">//初始化</span></span><br><span class="line">lengthList ( );              <span class="comment">//求表长</span></span><br><span class="line">GetList (<span class="keyword">int</span> i);             <span class="comment">//取元素</span></span><br><span class="line">InsertList (  i, x);         <span class="comment">//插入</span></span><br><span class="line">DeleteList(<span class="keyword">int</span> i);           <span class="comment">//删除</span></span><br><span class="line">LocateList(  x);             <span class="comment">//定位</span></span><br></pre></td></tr></table></figure>
<h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>顺序存储（数组）：连续的按排列顺序存储表中元素</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAXSIZE  100                <span class="comment">// 假设最大容量</span></span></span><br><span class="line">  <span class="keyword">typedef</span>  <span class="keyword">int</span>  ElemType;         <span class="comment">// 假设元素类型为int, 具体根据实际情况确定</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">           ElemType   elem[MAXSIZE];       <span class="comment">//数组</span></span><br><span class="line">           <span class="keyword">int</span>  length ;               <span class="comment">//元素实际个数</span></span><br><span class="line">   &#125; SeqList; </span><br></pre></td></tr></table></figure>

<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">InsertList</span> <span class="params">( Sqlist &amp;L,  <span class="keyword">int</span>  i,   ElemType  e )</span></span></span><br><span class="line"><span class="function"></span>&#123;                     </span><br><span class="line">     <span class="keyword">if</span> (L.length==MAXSIZE)       </span><br><span class="line">                     <span class="built_in">printf</span>( “表满” );   </span><br><span class="line">     <span class="keyword">else</span>  <span class="keyword">if</span> ( i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span> )      </span><br><span class="line">                    <span class="built_in">printf</span>( “位置错” ); </span><br><span class="line">     <span class="keyword">else</span> &#123;                       </span><br><span class="line">               <span class="keyword">for</span>( j=L.length<span class="number">-1</span> ;  j&gt;=i<span class="number">-1</span> ;  j-- )   <span class="comment">//移动元素，腾空间</span></span><br><span class="line">                        L.elem[ j+<span class="number">1</span>]=L.elem[ j];  </span><br><span class="line"></span><br><span class="line">                L.elem[i<span class="number">-1</span>]=e;    <span class="comment">//插入 </span></span><br><span class="line">                L.length++;      <span class="comment">//表长加1</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">DeleteList</span><span class="params">( SqList &amp;L,  <span class="keyword">int</span> i  )</span> <span class="comment">/*   删除第i个元素   */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( L.length==<span class="number">0</span> )      </span><br><span class="line">               <span class="built_in">printf</span>(“表空”);</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">if</span> ( i&lt;<span class="number">1</span>) || (i&gt;L.length )     </span><br><span class="line">                            <span class="built_in">printf</span>(“i值不合理”);</span><br><span class="line">                   <span class="keyword">else</span>      </span><br><span class="line">                          &#123;          <span class="comment">//数据向前移动 , 覆盖第i个元素 </span></span><br><span class="line">                                 <span class="keyword">for</span> ( j=i ;  j &lt; L.length ;  j++ )</span><br><span class="line">                                          L.elem[ j<span class="number">-1</span>] = L.elem[ j ]; </span><br><span class="line"></span><br><span class="line">                                  L.length--;     <span class="comment">//表长减1</span></span><br><span class="line">                          &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">Locate</span> <span class="params">( SqList L  , ElemType  x )</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span>  i=<span class="number">0</span>; i&lt;L.length ; i++ )    <span class="comment">//遍历 </span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>  ( e == L.data[i] )  </span><br><span class="line">                        <span class="keyword">return</span>  i+<span class="number">1</span> ;      <span class="comment">//找到，返回位置</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span>   <span class="number">0</span> ;     <span class="comment">//没有找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p>链式存储：每个元素存有后继元素的地址</p>
<ul>
<li>结点在内存的位置任意，不一定连续。</li>
<li>用“指针”（地址）将它们链连起来。<br>每个”结点”含有两部分：元素值、指针</li>
</ul>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//     结点      </span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>  &#123;</span></span><br><span class="line">      ElemType        data;    <span class="comment">//数据 </span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span>   <span class="title">Node</span>     *<span class="title">next</span>;</span>   <span class="comment">//指针    </span></span><br><span class="line">  &#125; LNode,  *LinkList;   </span><br></pre></td></tr></table></figure>

<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><h5 id="创建单链表（头插）"><a href="#创建单链表（头插）" class="headerlink" title="创建单链表（头插）"></a>创建单链表（头插）</h5><ol>
<li>建立头结点<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">L=(LinkList) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li>
<li>建立新结点<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p=(LinkList) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(LNode));</span><br></pre></td></tr></table></figure></li>
<li>插入在头部<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;next=L-&gt;next;</span><br><span class="line">L-&gt;next=p;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">LinkList   <span class="title">Creat</span> <span class="params">( <span class="keyword">int</span>  n)</span>        <span class="comment">/*     建立长度为n的单链表( 头插法)     */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   LinkList   L=(LinkList) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(LNode));      <span class="comment">//建立头结点</span></span><br><span class="line">   L-&gt;next=<span class="literal">NULL</span>  ;                   <span class="comment">//初始也是尾结点</span></span><br><span class="line">    <span class="keyword">for</span>  (<span class="keyword">int</span>  i=<span class="number">1</span>; i&lt;=n;  i++)     </span><br><span class="line">    &#123;</span><br><span class="line">                s=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));               <span class="comment">//新结点</span></span><br><span class="line">         <span class="built_in">scanf</span>(“%d”, s-&gt;data);                        <span class="comment">//输入数据元素                  </span></span><br><span class="line">                p-&gt;next=L-&gt;next;               <span class="comment">//插入在表头</span></span><br><span class="line">         L-&gt;next=p;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>   L ;        <span class="comment">//返回头指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建结点"><a href="#创建结点" class="headerlink" title="创建结点"></a>创建结点</h5><p>当建立新结点时，需要申请一个结点空间。如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p=(ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode))</span><br></pre></td></tr></table></figure>
<p>将该空间的首地址存入指针变量P中。</p>
<h5 id="释放结点"><a href="#释放结点" class="headerlink" title="释放结点"></a>释放结点</h5><p>动态分配的存储空间在用完后一定要释放。否则，造成内存泄露。如：<br>    free(p)<br>释放由p指向的内存区（结点）。</p>
<h5 id="按序号查找"><a href="#按序号查找" class="headerlink" title="按序号查找"></a>按序号查找</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList   <span class="title">Get_LinkList</span><span class="params">(LinkList H，<span class="keyword">int</span> k )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  j=<span class="number">1</span>;                  </span><br><span class="line">        LinkList  p=H ;    <span class="comment">//从头开始</span></span><br><span class="line">        <span class="keyword">while</span>( p-&gt;next &amp;&amp; j&lt;k)   &#123;</span><br><span class="line">                 p=p-&gt;next;       <span class="comment">//p移动到下一个结点</span></span><br><span class="line">                 j++;</span><br><span class="line">         &#125;</span><br><span class="line">          <span class="keyword">if</span>(j==k)   </span><br><span class="line">                 <span class="keyword">return</span>   p ;   <span class="comment">//找到第k个元素，返回指针</span></span><br><span class="line">           <span class="keyword">else</span>   </span><br><span class="line">                 <span class="keyword">return</span>  null;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><p>修改 p 的后继地址：<br>p-&gt;next = p-&gt;next-&gt;next</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">Del_LinkList</span><span class="params">(  LinkList  &amp;H ,  <span class="keyword">int</span> i  )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	LinkList   q  ,  p;</span><br><span class="line">	p=Get_LinkList(H,i<span class="number">-1</span>);    <span class="comment">//寻找第i-1个元素  </span></span><br><span class="line">	<span class="keyword">if</span> ( p-&gt;next==<span class="literal">NULL</span> ) </span><br><span class="line">	           <span class="built_in">printf</span>(“第i个元素不存在 “);</span><br><span class="line">	<span class="keyword">else</span>  &#123;</span><br><span class="line">                             q = p-&gt;next;               <span class="comment">// q是p的后继，即第i个结点   </span></span><br><span class="line">	             p-&gt;next = q-&gt;next;	 <span class="comment">//修改链，删除q </span></span><br><span class="line">	             e = q-&gt;data;                </span><br><span class="line">	             <span class="built_in">free</span>(q);                    <span class="comment">//释放q  </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h5><p><img src="/images/image-20211125182237140.png" alt="image-20211125182237140"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Insert_LinkList</span><span class="params">( LinkList &amp;L,  <span class="keyword">int</span>  i  ,   ElemType  x )</span>      </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	LinkList  s , p;</span><br><span class="line">	p=Get_LinkList(H,i<span class="number">-1</span>);   <span class="comment">/* 寻找i的前驱结点，让p指向它 */</span></span><br><span class="line">	<span class="keyword">if</span> (p==<span class="literal">NULL</span> || j &gt; i<span class="number">-1</span>) </span><br><span class="line">		<span class="built_in">printf</span>(“第i个元素不存在 “);</span><br><span class="line">	<span class="keyword">else</span>  &#123;</span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));     <span class="comment">/*  创建新结点 */</span></span><br><span class="line">		s-&gt;data = e;  </span><br><span class="line">		s-&gt;next = p-&gt;next;       <span class="comment">/* 修改链，插入在p之后  */</span></span><br><span class="line">		p-&gt;next = s;   </span><br><span class="line">	&#125;        </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>尾结点的后继是头结点 </p>
<p><img src="/images/image-20211125195853719.png" alt="image-20211125195853719"></p>
<p>从任一结点出发可以到达其它结点</p>
<p><img src="/images/image-20211125195925107.png" alt="image-20211125195925107"></p>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>每个结点有两个指针，分别指向其前驱和后继。</p>
<p><strong>优点</strong>： 双向遍历</p>
<p><img src="/images/image-20211125200011789.png" alt="image-20211125200011789"></p>
<h5 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h5><p><img src="/images/image-20211125200048655.png" alt="image-20211125200048655"></p>
<p>修改4个指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">① s.prior=p.prior;  </span><br><span class="line">② p.prior.next=s;</span><br><span class="line">③ s.next=p;        </span><br><span class="line">④ p.prior=s;</span><br></pre></td></tr></table></figure>


<h5 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h5><p><img src="/images/image-20211125200149823.png" alt="image-20211125200149823"></p>
<p>修改2个指针</p>
<pre><code>① p.prior.next=p.next;
② p.next.prior =p.prior;
</code></pre>
<h4 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h4><p><strong>顺序表：</strong></p>
<ol>
<li><p>存储紧凑；</p>
</li>
<li><p>可以快速地存取表中任一位置的元素； </p>
</li>
<li><p>插入删除元素需要移动大量元素；</p>
</li>
<li><p>表的容量难以确定和扩充。</p>
</li>
</ol>
<p><strong>链表：</strong></p>
<ol>
<li><p>插入删除仅需修改指针；</p>
</li>
<li><p>表的长度可以动态变化；</p>
</li>
<li><p>存取某元素需要从头遍历表；</p>
</li>
<li><p>每个元素需要附加一个指针域。</p>
</li>
</ol>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈(Stack)是限制在表的一端进行插入和删除运算的线性表，插入、删除的一端为栈顶(Top)，另一端为栈底(Bottom)。top== -1时为空栈，top==0只能说明栈中只有一个元素，元素进栈时top自增<br><strong>特性</strong>：先进后出<br><strong>存储结构：</strong>顺序存储、链式存储<br>顺序存储栈（数组）：顺序存储结构<br>链栈：链式存储结构。插入和删除仅在链头操作。栈顶指针是链表的头指针。不需要判断栈满，只需要判断栈空。<br><strong>栈空：</strong>top == -1<br><strong>栈满：</strong> top = max-1<br>**双栈共用共享：栈1的底在V[1]，栈2的底在V[m]，栈满条件： **top[1]+1=top[2]。</p>
<p>n个元素入栈，可能的出栈序列有C(2n,n)/(n+1)个。（C(2n，n)，求2n前n位的阶乘）</p>
<h4 id="双栈共享"><a href="#双栈共享" class="headerlink" title="双栈共享"></a>双栈共享</h4><p>一个数组用于两个栈</p>
<p><img src="/images/image-20211125203249109.png" alt="image-20211125203249109"></p>
<p>栈满： top1+1==top2</p>
<p>栈1空：top1==-1</p>
<p>栈2空：top2==M (M为顺序表容量）</p>
<p>入栈1：top1++</p>
<p>入栈2:  top2– </p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p><img src="/images/image-20211125201635557.png" alt="image-20211125201635557"></p>
<p>队列(Queue)也是一种运算受限的线性表。插入和删除分别在两端，意味着它只允许在表的一端进行插入，而在另一端进行删除。允许删除的一端称为队头(front)，允许插入的一端称为队尾(rear)。<br><strong>特性</strong>：先进先出。<br><strong>队空条件：</strong>rear == front<br><strong>队满条件：</strong>（rear+1）% MAX = = front    （MAX=队列的最大长度）<br><strong>计算队列长度：</strong>（rear-front+QueueSize）% QueueSize<br><strong>入队：</strong>（rear+1）% QueueSize = rear<br><strong>出队：</strong>（front+1）% QueueSize = front</p>
<h4 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h4><p><img src="/images/image-20211125201744158.png" alt="image-20211125201744158"></p>
<p>定义链队列：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>   <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       LNode  * front;</span><br><span class="line">       LNode  *rear;</span><br><span class="line">&#125; LinkQueue;</span><br></pre></td></tr></table></figure>

<p>链式存储结构。限制仅在表头删除和表尾插入的单链表。显然仅有单链表的头指针不便于在表尾做插入操作，为此再增加一个尾指针，指向链表的最后一个结点。</p>
<h5 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h5><p>删除队首</p>
<p><img src="/images/image-20211125201901938.png" alt="image-20211125201901938"></p>
<p>修改指针：Q. front -&gt; next = p-&gt;next;</p>
<p>释放结点：free(p)</p>
<h5 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h5><p>插入队尾</p>
<p><img src="/images/image-20211125202031693.png" alt="image-20211125202031693"></p>
<p>插入队尾： Q.rear-&gt;next = p;</p>
<p>新队尾  ： Q.rear = p ; </p>
<h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><p>顺序存储结构。当头尾指针相等时队列为空。在非空队列里，头指针始终指向队头前一个位置，而尾指针始终指向队尾元素的实际位置。</p>
<p><img src="/images/image-20211125202133611.png" alt="image-20211125202133611"></p>
<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>循环队列。在循环队列中进行出队、入队操作时，头尾指针仍要加1，朝前移动。只不过当头尾指针指向向量上界（MaxSize-1）时，其加1操作的结果是指向向量的下界0。除非向量空间真的被队列元素全部占用，否则不会上溢。因此，除一些简单的应用外，真正实用的顺序队列是循环队列。故队空和队满时头尾指针均相等。因此，我们无法通过front=rear来判断队列“空”还是“满”。</p>
<p><img src="/images/image-20211125202244592.png" alt="image-20211125202244592"></p>
<p>**队头指针移动一个位置:**front = (front+1) % Size</p>
<p><strong>队尾指针移动一个位置:</strong> rear = (rear+1) % size</p>
<p><img src="/images/image-20211125202845060.png" alt="image-20211125202845060"></p>
<h5 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h5><p><img src="/.top//Typora\image-20211125202931015.png" alt="image-20211125202931015"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q , DataType &amp;x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( Q.front==Q.rear )  </span><br><span class="line">		   <span class="built_in">printf</span>(<span class="string">&quot;队列空!&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">         &#123;	</span><br><span class="line">	          x=Q.base[Q.front];        <span class="comment">// 删除 </span></span><br><span class="line">	          Q.front=(Q.front+<span class="number">1</span>)%M;  <span class="comment">//新的队头  </span></span><br><span class="line">	   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20211125203030591.png" alt="image-20211125203030591"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q , ElemType  x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( (Q.rear+<span class="number">1</span>)%M==Q.front )  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;队列满!&quot;</span>);</span><br><span class="line">	 <span class="keyword">else</span>  </span><br><span class="line">         &#123;</span><br><span class="line">	           Q.base[Q.rear] = x;       <span class="comment">// 插入 </span></span><br><span class="line">	           Q.rear=(Q.rear+<span class="number">1</span>)%M;   <span class="comment">// 新的队尾  </span></span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><h3 id="树的定义和基本术语"><a href="#树的定义和基本术语" class="headerlink" title="树的定义和基本术语"></a>树的定义和基本术语</h3><h4 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h4><p><img src="/images/image-20211201192649382.png" alt="image-20211201192649382"></p>
<ul>
<li><p>一个“根”：A</p>
</li>
<li><p>一些“子树”：T1={B,D,E,F,H,I} ,     T2={C,G}</p>
</li>
<li><p>每个子树还有自己的根和子树</p>
</li>
<li><p>树是非线性结构</p>
</li>
<li><p>元素是“一对多”关系</p>
</li>
<li><p>树是层次结构</p>
</li>
</ul>
<p><img src="/images/image-20211201192944437.png" alt="image-20211201192944437"></p>
<p>树的各种表示：</p>
<p><img src="/images/image-20211201193151162.png" alt="image-20211201193151162"></p>
<h4 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h4><ul>
<li>结点</li>
<li>结点的度</li>
<li>叶子结点</li>
<li>分支结点</li>
<li>孩子结点</li>
<li>父亲结点</li>
<li>兄弟结点</li>
<li>祖先结点</li>
<li>树的度</li>
<li>结点的层次</li>
<li>树的深度</li>
<li>森林</li>
</ul>
<p><img src="/images/image-20211201193519967.png" alt="image-20211201193519967"></p>
<h3 id="二叉树的性质与存储"><a href="#二叉树的性质与存储" class="headerlink" title="二叉树的性质与存储"></a>二叉树的性质与存储</h3><p><strong>二叉树：</strong> 每个结点最多有2个子树，有左右子树之分 。</p>
<p><img src="/images/image-20211201193757387.png" alt="image-20211201193757387"></p>
<p><strong>二叉树的5种基本形态：</strong></p>
<p><img src="/images/image-20211201194331751.png" alt="image-20211201194331751"></p>
<p><strong>满二叉树：</strong>所有分支结点都有2棵子树；所有叶子结点都在同一层上。</p>
<p><img src="/images/image-20211201194446257.png" alt="image-20211201194446257"></p>
<p><strong>完全二叉树：</strong>完全二叉树 上面的层都是满的，最后一层可以缺右边的连续个叶子</p>
<p><img src="/images/image-20211201194525417.png" alt="image-20211201194525417"></p>
<h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4><p><strong>性质1</strong> ：一棵非空的二叉树的第 i 层上至多有 2i －1个结点(i ³ 1)。</p>
<p><img src="/images/image-20211201194646997.png" alt="image-20211201194646997"></p>
<p><strong>性质2</strong>：一棵深度为k的二叉树中，最多具有2k－1个结点。  </p>
<p>总的结点数＝第1层+第2层+第3层+ …+ 第k层</p>
<pre><code>    ≤  20 +  21 + 22  +… + 2k-1   = 2k -1
</code></pre>
<p><strong>性质3</strong>：对于一棵非空的二叉树，如果叶子结点数为n0，度数为2的结点数为n2，则有: n0＝n2＋1。</p>
<p> 总的结点数：      n=n0+n1+n2    ①<br> 总的分支数：      B=n1+2n2       ②<br> 总的分支数：      B=n-1        ③<br> 由①②③ 得 ：     n0=n2+1  </p>
<p><strong>性质4</strong>： 具有n个结点的完全二叉树的深度为 ⌊ log2n ⌋+1。<br>   2h-1 ≤ n ≤ 2h-1<br>   2h-1 ≤ n ＜ 2h<br>   h-1 ≤ log2n ＜ h<br>   h = [log2n]＋1  </p>
<p><img src="/images/image-20211201194947312.png" alt="image-20211201194947312"></p>
<p><strong>性质5</strong>：对于完全二叉树，对结点从左到右按层从1开始编号，则对于序号为i的结点，有：<br>（1）如果i＝1，则该结点是根结点；<br>（2）序号为i的结点的左子结点的序号为2i；<br>（3）序号为i的结点的右子结点的序号为2i＋1；<br> (4)  序号为i的结点的父结点的序号为 ⌊i/2⌋。</p>
<p><img src="/images/image-20211201195128014.png" alt="image-20211201195128014"></p>
<p><img src="/images/image-20211201195152422.png" alt="image-20211201195152422"></p>
<p>极端情况：</p>
<p><img src="/images/image-20211201195245224.png" alt="image-20211201195245224"></p>
<h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p><img src="/images/image-20211201195408608.png" alt="image-20211201195408608"></p>
<p><strong>二叉链表的两种表示：</strong></p>
<p><img src="/images/image-20211201195613903.png" alt="image-20211201195613903"></p>
<p><strong>三叉链表：</strong>添加一个指针，指向双亲</p>
<p><img src="/images/image-20211201195651741.png" alt="image-20211201195651741"></p>
<p><img src="/images/image-20211201195902273.png" alt="image-20211201195902273"></p>
<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p> 访问二叉树中的每个结点，使每个结点仅被访问一次。</p>
<p>依次遍历二叉树中的<strong>三个组成部分</strong></p>
<p><img src="/images/image-20211201195945963.png" alt="image-20211201195945963"></p>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>先序遍历（DLR）<br>若非空，则：<br> (1)  访问根结点；<br> (2)  先序遍历左子树；<br> (3)  先序遍历右子树。 </p>
<p><img src="/images/image-20211201200106422.png" alt="image-20211201200106422"></p>
<p><strong>注意</strong>：子树也是一棵树，也要按照先序遍历</p>
<p><img src="/images/image-20211201200237413.png" alt="image-20211201200237413"></p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历（DLR）<br>若二叉树非空，则<br> (1)  中序遍历左子树；<br> (2)  访问根 ；<br> (3)  中序遍历右子树。 </p>
<p><img src="/images/image-20211201200429967.png" alt="image-20211201200429967"></p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p> 若二叉树非空，则：<br> (1)  后序遍历左子树；<br> (2)  后序遍历右子树；<br> (3)  访问根 。 </p>
<p><img src="/images/image-20211201200703220.png" alt="image-20211201200703220"></p>
<p><strong>遍历二叉树归纳：</strong></p>
<p><img src="/images/image-20211201200639947.png" alt="image-20211201200639947"></p>
<p><img src="/images/image-20211201201112368.png" alt="image-20211201201112368"></p>
<h4 id="遍历二叉树递归程序"><a href="#遍历二叉树递归程序" class="headerlink" title="遍历二叉树递归程序"></a><strong>遍历二叉树递归程序</strong></h4><p><strong>先序遍历：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">preOrder</span><span class="params">( BiTree  root )</span>  </span>&#123;   </span><br><span class="line">         <span class="keyword">if</span>  (root!=<span class="literal">NULL</span>)  &#123;</span><br><span class="line">                   visite( root );       <span class="comment">//访问根</span></span><br><span class="line">                   preOrder(root.lchild);    <span class="comment">//遍历左子树</span></span><br><span class="line">                   preOrder(root.rchild);  <span class="comment">//遍历右子树</span></span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>中序遍历：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">inOrder</span><span class="params">( BiTree  root )</span>  </span>&#123;   </span><br><span class="line">         <span class="keyword">if</span>  (root!=<span class="literal">NULL</span>)  &#123;</span><br><span class="line">	inOrder(root.lchild);    <span class="comment">//遍历左子树</span></span><br><span class="line">                    visite( root );      <span class="comment">//访问根</span></span><br><span class="line">	inOrder(root.rchild);  <span class="comment">//遍历右子树</span></span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>后续遍历：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">postOrder</span><span class="params">( BiTree  root )</span>  </span>&#123;   </span><br><span class="line">         <span class="keyword">if</span>  (root!=<span class="literal">NULL</span>)  &#123;</span><br><span class="line">	postOrder(root.lchild);    <span class="comment">//遍历左子树</span></span><br><span class="line">                postOrder(root.rchild);  <span class="comment">//遍历右子树</span></span><br><span class="line">       	visite( root);      <span class="comment">//访问根</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="二叉树的应用"><a href="#二叉树的应用" class="headerlink" title="二叉树的应用"></a>二叉树的应用</h3><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><h4 id="查找表的结构"><a href="#查找表的结构" class="headerlink" title="查找表的结构"></a>查找表的结构</h4><p>查找表的结构，决定了查找数据的方式</p>
<ul>
<li>查找表是一组无序的数据；</li>
<li>查找表是一组有序的数据；</li>
<li>查找表是线性结构；</li>
<li>查找表是非线性结构。</li>
</ul>
<h4 id="查找分类"><a href="#查找分类" class="headerlink" title="查找分类"></a>查找分类</h4><p><strong>静态查找表</strong><br>只查找，不改变表的数据</p>
<p><strong>动态查找表</strong><br>在查找过程中，修改表中的数据（插入、删除）</p>
<p><strong>平均查找长度（平均比较次数）</strong></p>
<p><img src="/images/image-20211202160554475.png" alt="image-20211202160554475"></p>
<p><strong>顺序查找</strong></p>
<p><img src="/images/image-20211202160712072.png" alt="image-20211202160712072"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">linerSearch</span> <span class="params">( SeqRList  L ,    keyType  k )</span>   </span>&#123;</span><br><span class="line"></span><br><span class="line">        L.r[ <span class="number">0</span> ] .key = k;      <span class="comment">//监视哨</span></span><br><span class="line">        i=L.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( L.r[ i ] .key != k)    <span class="comment">//反向查找</span></span><br><span class="line">                  i--;  </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span>     i;     <span class="comment">//返回位置，失败时i=0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：算法简单，适应面广</p>
<p><strong>缺点</strong>：平均查找长度大，</p>
<p><strong>顺序查找的性能</strong></p>
<p><img src="/images/image-20211202160745279.png" alt="image-20211202160745279"></p>
<p><img src="/images/image-20211202160833368.png" alt="image-20211202160833368"></p>
<h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p><img src="/images/image-20211202185151523.png" alt="image-20211202185151523"></p>
<p><img src="/images/image-20211202185241561.png" alt="image-20211202185241561"></p>
<p><strong>折半查找性能</strong></p>
<p><img src="/images/image-20211202185315320.png" alt="image-20211202185315320"></p>
<p><strong>折半查找实现</strong></p>
<p><img src="/images/image-20211202185346353.png" alt="image-20211202185346353"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">binarySearch</span><span class="params">( SSTable  ST,  <span class="keyword">int</span>  key )</span>   </span>&#123;</span><br><span class="line"></span><br><span class="line">	     <span class="keyword">int</span>    low = <span class="number">1</span> ， high = ST.length;      <span class="comment">// 初始上界、下界</span></span><br><span class="line"></span><br><span class="line">	     <span class="keyword">while</span> ( low &lt;= high )   &#123;</span><br><span class="line">		    <span class="keyword">int</span>   mid = ( low+high )/<span class="number">2</span>;     <span class="comment">// 中间位置</span></span><br><span class="line">		    <span class="keyword">if</span> ( key == ST.elem[mid] )</span><br><span class="line">			     <span class="keyword">return</span>    mid;           <span class="comment">//成功，返回位置</span></span><br><span class="line">		    <span class="keyword">else</span>  <span class="keyword">if</span> ( key &lt; a[mid] )</span><br><span class="line">			      high = mid<span class="number">-1</span>;         <span class="comment">//左半边继续查找</span></span><br><span class="line">		    <span class="keyword">else</span></span><br><span class="line">			      low = mid+<span class="number">1</span>;      <span class="comment">//右半边继续查找</span></span><br><span class="line">	     &#125;</span><br><span class="line">	     <span class="keyword">return</span>    <span class="number">0</span>;     <span class="comment">// 失败</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>索引表查找</strong></p>
<p><img src="/images/image-20211202185455002.png" alt="image-20211202185455002"></p>
<h3 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h3><p><strong>哈希表查找（散列）</strong></p>
<p>查找时不需要进行比较；<br>直接通过公式直接计算出元素的地址（位置）。</p>
<p><img src="/images/image-20211202185609904.png" alt="image-20211202185609904"></p>
<p><img src="/images/image-20211202185659001.png" alt="image-20211202185659001"></p>
<p><img src="/images/image-20211202185709009.png" alt="image-20211202185709009"></p>
<h4 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h4><h5 id="直接地址法"><a href="#直接地址法" class="headerlink" title="直接地址法"></a>直接地址法</h5><p><img src="/images/image-20211202185808890.png" alt="image-20211202185808890"></p>
<h5 id="除留取余法"><a href="#除留取余法" class="headerlink" title="除留取余法"></a>除留取余法</h5><p><img src="/images/image-20211202185833888.png" alt="image-20211202185833888"></p>
<h5 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h5><p><img src="/images/image-20211202185853290.png" alt="image-20211202185853290"></p>
<h5 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h5><p><img src="/images/image-20211202185909642.png" alt="image-20211202185909642"></p>
<h4 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h4><h5 id="开放定址法之“线性探测法-”"><a href="#开放定址法之“线性探测法-”" class="headerlink" title="开放定址法之“线性探测法 ”"></a>开放定址法之“线性探测法 ”</h5><p>若在地址t处冲突，则从t开始顺次探测相邻的下一个空闲位置</p>
<p><img src="/images/image-20211202190015633.png" alt="image-20211202190015633"></p>
<p><strong>例：</strong></p>
<p><img src="/images/image-20211202190119763.png" alt="image-20211202190119763"></p>
<p><img src="/images/image-20211202190146220.png" alt="image-20211202190146220"></p>
<h5 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h5><p>相同地址的关键字，同一个链表中                    </p>
<p><img src="/images/image-20211202190235561.png" alt="image-20211202190235561"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>傻妞机器人sillyGirl安装部署</title>
    <url>/2021/11/09/%E5%82%BB%E5%A6%9E%E6%9C%BA%E5%99%A8%E4%BA%BAsillyGirl%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>以下内容版本截至11月9日可用，后续若有更改会定期进行更新，懒人请直接进入首页左侧导航栏“狗东京豆”上车。机器人需配合青龙面板使用，若还未搭建青龙面板请先移步<a href="https://train2000.top/2021/10/16/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF-xdd-plus%E5%B0%8F%E7%99%BD%E6%95%99%E7%A8%8B/">青龙面板+xdd-plus小白教程</a>  查看相关内容</p>
<span id="more"></span>

<h4 id="安装go环境"><a href="#安装go环境" class="headerlink" title="安装go环境"></a>安装go环境</h4><h5 id="下载go安装包"><a href="#下载go安装包" class="headerlink" title="下载go安装包"></a>下载go安装包</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span> &amp;&amp; wget https://golang.google.cn/dl/go1.16.7.linux-amd64.tar.gz -O go1.16.7.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>



<h5 id="解压安装包"><a href="#解压安装包" class="headerlink" title="解压安装包"></a>解压安装包</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvzf go1.16.7.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<h5 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure>
<p>复制下面内容到文件最后面（进入文件按shift+g直接跳到最后一行，然后按o在下一行输入）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn</span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go</span><br><span class="line"><span class="built_in">export</span> GOPATH=/usr/<span class="built_in">local</span>/go/path</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin:<span class="variable">$GOPATH</span>/bin</span><br></pre></td></tr></table></figure>
<p>编辑完后先按esc，再按shift+g，输入wq，保存并退出。<br><strong>注：用宝塔面板的直接找到文件打开粘贴到最后面即可。</strong></p>
<p>记得使用source命令使环境变量生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
<p>最后查看go是否完成安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure>
<p><img src="/images/go_sucess.jpg"></p>
<h4 id="安装傻妞"><a href="#安装傻妞" class="headerlink" title="安装傻妞"></a>安装傻妞</h4><h5 id="拉取机器人库"><a href="#拉取机器人库" class="headerlink" title="拉取机器人库"></a>拉取机器人库</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~ &amp;&amp; git <span class="built_in">clone</span> https://ghproxy.com/https://github.com/cdle/sillyGirl</span><br></pre></td></tr></table></figure>
<h5 id="拉取京东组件库"><a href="#拉取京东组件库" class="headerlink" title="拉取京东组件库"></a>拉取京东组件库</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> sillyGirl/develop &amp;&amp; git <span class="built_in">clone</span> https://ghproxy.com/https://github.com/ufuckee/jd_cookie</span><br></pre></td></tr></table></figure>

<h5 id="新建dev-go文件"><a href="#新建dev-go文件" class="headerlink" title="新建dev.go文件"></a>新建dev.go文件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/sillyGirl &amp;&amp; vi dev.go</span><br></pre></td></tr></table></figure>
<p>把以下内容放进去</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"></span><br><span class="line"><span class="comment">//青龙2.9机器人</span></span><br><span class="line">_<span class="string">&quot;github.com/cdle/sillyGirl/develop/qinglong&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//京东账号</span></span><br><span class="line">_ <span class="string">&quot;github.com/cdle/sillyGirl/develop/jd_cookie&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//腾讯QQ</span></span><br><span class="line">_<span class="string">&quot;github.com/cdle/sillyGirl/im/qq&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Te Legram</span></span><br><span class="line">_<span class="string">&quot;github.com/cdle/sillyGirl/im/tg&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//微信公众号</span></span><br><span class="line">_<span class="string">&quot;github.com/cdle/sillyGirl/im/wxmp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//微信号</span></span><br><span class="line">_<span class="string">&quot;github.com/cdle/sillyGirl/im/wx&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>记得wq保存退出</p>
<h5 id="编译并启动机器人"><a href="#编译并启动机器人" class="headerlink" title="编译并启动机器人"></a>编译并启动机器人</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build</span><br><span class="line">chmod 777 sillyGirl    </span><br><span class="line">./sillyGirl       </span><br></pre></td></tr></table></figure>

<p>等待弹出二维码，记得用需要做机器人的qq扫描，登录成功后开始配置傻妞。</p>
<h4 id="配置傻妞"><a href="#配置傻妞" class="headerlink" title="配置傻妞"></a>配置傻妞</h4><p>扫码完成登录后，先不要退出，接下来对傻妞进行配置：</p>
<p>用qq机器人给机器人自己发送以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设置管理员账号</span><br><span class="line">set qq masters 用于管理的QQ号（不是机器人的qq）</span><br><span class="line"></span><br><span class="line">禁用机器人自己回复信息</span><br><span class="line">set qq onself false</span><br></pre></td></tr></table></figure>
<p>接下来就可以用管理员qq开始配置了</p>
<p><strong>必需配置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设置青龙openapi的client_id参数</span><br><span class="line">set qinglong client_id ?</span><br><span class="line"></span><br><span class="line">设置青龙openapi的client_secret参数</span><br><span class="line">set qinglong client_secret ?</span><br><span class="line"></span><br><span class="line">设置青龙面板地址</span><br><span class="line">set qinglong host http://青龙IP地址:青龙端口号</span><br></pre></td></tr></table></figure>

<p><strong>可选配置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">傻妞机器人名</span><br><span class="line">set sillyGirl name 傻妞</span><br><span class="line"></span><br><span class="line">傻妞http服务端口</span><br><span class="line">set sillyGirl port 8080</span><br><span class="line"></span><br><span class="line">傻妞消息撤回等待时间，单位秒</span><br><span class="line">set sillyGirl duration 5</span><br><span class="line"></span><br><span class="line">傻妞自动升级是否通知</span><br><span class="line">set sillyGirl update_notify false</span><br><span class="line"></span><br><span class="line">是否开启傻妞自动更新</span><br><span class="line">set sillyGirl auto_update true</span><br><span class="line"></span><br><span class="line">青龙是否开启自动隐藏重复任务功能</span><br><span class="line">set qinglong autoCronHideDuplicate true</span><br><span class="line"></span><br><span class="line">设置是否自动同意好友请求</span><br><span class="line">set qq auto_friend false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置完后记得重启傻妞</p>
<h5 id="重启傻妞"><a href="#重启傻妞" class="headerlink" title="重启傻妞"></a>重启傻妞</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -A|grep sillyGirl <span class="comment">##显示进程号</span></span><br><span class="line"><span class="built_in">kill</span> -9 xxxxxx <span class="comment">##杀掉进程</span></span><br><span class="line"><span class="built_in">cd</span> ~/sillyGirl &amp;&amp; ./sillyGirl  <span class="comment">##启动傻妞</span></span><br></pre></td></tr></table></figure>
<p>等待加载数据库完成，出现以下内容表示机器人配置成功<br><img src="/images/silly_ok.jpg"></p>
<p>按ctrl+c退出，输入以下内容让傻妞静默挂机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./sillyGirl -d</span><br></pre></td></tr></table></figure>



<p>傻妞配置相关内容结束</p>
]]></content>
      <categories>
        <category>青龙面板</category>
      </categories>
      <tags>
        <tag>傻妞机器人</tag>
        <tag>sillyGirl</tag>
        <tag>青龙</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理与体系结构</title>
    <url>/2021/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<style>
    .indent{
        text-indent:2em;
    }
    .unline{text-decoration:underline;}
    .cankao,.span_notice{
    color:red;
    }
</style>
<h3 id="数据的表示"><a href="#数据的表示" class="headerlink" title="数据的表示"></a>数据的表示</h3><h4 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示"></a>进制表示</h4><p class="indent">R进制转十进制使用按权展开法，其具体操作方式为∶将R进制数的每一位数值用R的k次方形式表示，即幂的底数是R，指数为k ，k与该位和小数点之间的距离有关。当该位位于小数点左边，k值是该位和小数点之间数码的个数,而当该位位于小数点右边，k值是负值，其绝对值是该位和小数点之间数码的个数加1。</p>

<p>例：<br>二进制11010.11 = 1 x 2^4 + 1 x 2^3 + 0 x 2^2 + 1 x 2^1 + 0 x 2^0 + 1 x 2^-1 + 1 x 2^-2=26.75<br>六进制532.13 = 5 x 6^2 + 3 x 6^1 + 2 x 6^0 + 1 x 6^-1 + 3 x 6^-2</p>
<h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><h5 id="二进制与八进制"><a href="#二进制与八进制" class="headerlink" title="二进制与八进制"></a>二进制与八进制</h5><p>二进制转八进制：</p>
<p class="indent">从小数点开始，小数点前从小数点开始向左每三位为一组，最后不足三位的可以添0补足，小数点后向右每三位一组，不足三位必须添0补齐。然后将每组按权相加，即得到八进制数。</p>

<p>八进制转二进制：</p>
<p class="indent">同上面相似，从小数点开始向左右开始，把每一位数转换成二进制即可。</p>

<h5 id="二进制与十六进制"><a href="#二进制与十六进制" class="headerlink" title="二进制与十六进制"></a>二进制与十六进制</h5><p>二进制转十六进制：</p>
<p class="indent">与二进制和八进制的转换相似，每四位一组，然后再按权相加。需要注意的是，9之后的数用字母A--F表示，如13应表示为D。（注：末尾为H表示该数是十六进制数）</p>

<p>十六进制转二进制：</p>
<p class="indent">与八进制转二进制方法相同。</p>

<p>注：八进制与十六进制的转换，需先转为二进制，再转换成八进制或十六进制。</p>
<h5 id="十进制转R进制"><a href="#十进制转R进制" class="headerlink" title="十进制转R进制"></a>十进制转R进制</h5><p class="indent">十进制转R进制可以使用短除法。如将十进制的83转成3进制：</p>
 <ul>
 3|<span class="unline">83</span>&nbsp;&nbsp;&nbsp;&nbsp;余数&nbsp;&nbsp;2<br>
 3|<span class="unline">27</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
3|<span class="unline">9</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
 3|<span class="unline">3</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
&nbsp;&nbsp;&nbsp;<span>1</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>
 </ul>

<p>最后再从下往上读其余数，即十进制的83用3进制表示为：10002 。</p>
<p><span class="cankao">详情参考：</span><a href="https://www.bilibili.com/video/BV1yU4y1371J?p=3">https://www.bilibili.com/video/BV1yU4y1371J?p=3</a></p>
<h4 id="源码反码补码移码"><a href="#源码反码补码移码" class="headerlink" title="源码反码补码移码"></a>源码反码补码移码</h4><p><img src="/images/zhuanma.png" alt="码值转换"><br>源码：把一个数转成二进制即为它的源码（若为带符号的，取其最高位，每8位一组，不足8位的在前面添0补齐，正数首位为0，负数首位为1）。<br>反码：正数的反码是其本身，负数的反码是在其原码的基础上符号位不变，其余各个位取反<br>补码：正数的补码就是其本身，负数的补码是在其反码的基础上+1<br>移码：不管正负数，只要将其补码的符号位取反即可</p>
<p>表示范围：<br><br><img src="/images/zone.jpg" alt="表示范围"></p>
<p><span class="cankao">详情参考：</span><a href="https://www.bilibili.com/video/BV1yU4y1371J?p=4">https://www.bilibili.com/video/BV1yU4y1371J?p=4</a></p>
<h3 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h3><p class="indent">传统计算机一般由以下部分组成：运算器、控制器、存储器、I/O设备，运算器和控制器共同组成CPU（中央处理器），存储器又分为内存储器（RAM、ROM）和外存储器（硬盘、U盘、磁带等）。</p>

<p>运算器的构成：</p>
<ol>
<li>算术逻辑单元ALU</li>
<li>累加寄存器AC</li>
<li>数据缓冲寄存器DR</li>
<li>状态条件寄存器PSw</li>
</ol>
<p>控制器的构成：</p>
<ol>
<li>程序计数器PC</li>
<li>指令寄存器IR</li>
<li>指令译码器</li>
<li>时序部件</li>
</ol>
<p><span class="cankao">参考：</span><br><a href="https://www.bilibili.com/video/BV1yU4y1371J?p=6">https://www.bilibili.com/video/BV1yU4y1371J?p=4</a><br><br><a href="https://blog.csdn.net/L_gentleman/article/details/93377576">https://blog.csdn.net/L_gentleman/article/details/93377576</a></p>
<h3 id="flynn分类法"><a href="#flynn分类法" class="headerlink" title="flynn分类法"></a>flynn分类法</h3><p><img src="/images/flynn.jpg" alt="flynn分类法"></p>
<h3 id="CISC与RISC"><a href="#CISC与RISC" class="headerlink" title="CISC与RISC"></a>CISC与RISC</h3><p><img src="/images/CISC&RISC.jpg" alt="CISC与RISC"></p>
<p><span class="cankao">参考：</span><br><a href="https://www.bilibili.com/video/BV1yU4y1371J?p=8">https://www.bilibili.com/video/BV1yU4y1371J?p=4</a></p>
<h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><ol>
<li><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p class="indent">流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理是针对不同指令而言的，它们可以同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度。</p></li>
</ol>
<p>指令执行顺序： 取指—&gt;分析—&gt;执行</p>
<p><img src="/images/lsx_zxqk.jpg"></p>
<p class="indent">如图所示，在未使用流水线的情况下，需要先完成某一条指令的执行操作后，再进行下一条指令的操作；当使用了流水线后，只要前一条指令的一部分操作已完成，那么就会开始下一条指令的对应操作，从而减少了指令的处理时间。</p>

<ol start="2">
<li><h4 id="流水线的计算"><a href="#流水线的计算" class="headerlink" title="流水线的计算"></a>流水线的计算</h4></li>
</ol>
<p>直接上例题：</p>
<p class="indent">若指令流水线把一条指令分为取指、分析、执行三部分，且三部分的时间分别为取指2ns、分析2ns、执行1ns。求：流水线的周期是多少？100条指令全部执行完毕的时间是多少？</p>

<p><strong>知识引入：</strong></p>
<ul>
<li>流水线周期（▲t ）：执行时间最长的一段</li>
<li>流水线计算公式：<ol>
<li><span class="span_notice">一条指令执行完毕时间+（指令条数-1）* 流水线周期</span></li>
<li>理论公式：<span class="span_notice">(t1+t2+t3+…+tk)+(n-1)*▲t</span>  （考的比较多）</li>
<li>实践公式：<span class="span_notice">(k+n-1)*▲t</span></li>
</ol>
</li>
<li>k表示把一条指令分为了几部分</li>
<li>n表示一共有多少条指令</li>
</ul>
<p><strong>解答：</strong></p>
<p class="indent">在本题中，由于三部分时间最长的为取指和分析两部分，它们的时间都为2ns，即<span class="span_notice">流水线周期为2</span>；指令共有三部分，即<span class="span_notice">k为3</span> 。</p>
使用理论公式计算：(2+2+1)+(100-1)*2=203ns

<p>使用实践公式计算：(3+100-1)*2=204ns</p>
<ol start="3">
<li><h4 id="流水线吞吐量计算"><a href="#流水线吞吐量计算" class="headerlink" title="流水线吞吐量计算"></a>流水线吞吐量计算</h4></li>
</ol>
<p class="indent">流水线的吞吐率（Though  Put  rate，TP）是指在单位时间内流水线所完成的任务数量或输出的结果数量。公式如下：</p>
TP=指令条数/流水线执行时间

<p>流水线最大吞吐率： TP(max)=1/▲t </p>
<p class="indent">以上面的例题为例，其流水线周期为2ns，共有100条指令，执行完所有指令消耗的时间为203ns，那么该流水线的吞吐率为：</p>
TP = 100/203；
最大吞吐率为：
TP(max) = 1 / 2

<ol start="4">
<li><h4 id="流水线加速比计算"><a href="#流水线加速比计算" class="headerlink" title="流水线加速比计算"></a>流水线加速比计算</h4></li>
</ol>
<p>公式：<br>S = 不使用流水线执行时间/使用流水线执行时间</p>
<p class="indent">前面提到不使用流水线时，需要等当前指令执行结束后再开始执行下一条指令，因此，在这种情况下，执行一条指令所需要的时间为2+2+1=5ns，共有100条指令，故执行完所有指令所需的时间为500ns，而使用流水线的执行时间仅为203ns，所以流水线加速比为：</p>
S = 500 / 203



<h3 id="计算机层次化存储结构"><a href="#计算机层次化存储结构" class="headerlink" title="计算机层次化存储结构"></a>计算机层次化存储结构</h3><p>计算机存储结构如图：</p>
<p><img src="/images/cunchujiegou.jpg"></p>
<h3 id="cache的基本概念"><a href="#cache的基本概念" class="headerlink" title="cache的基本概念"></a>cache的基本概念</h3><p class="indent">cache的功能：提高CPU数据的I/O速率，突破了冯·诺依曼瓶颈，即CPU与存储系统间数据传送贷款限制。</p>
在计算机存储体系中，cache是访问速度最快的层次。
使用cache改善系统性能的依据是程序的局部性原理。


<p class="indent">如果以h代表队cache的访问命中率，t1表示cache的周期时间，t2表示煮存储器周期时间，以读操作为例，使用<span class="span_notice">cache+主存储器</span>的系统的平均周期为t3，则：
</p>

<pre><code>t3 = h * t1 + (1-h) * t2
</code></pre>
<p>其中，(1-h) 又称为失效率（未命中率）。</p>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><h4 id="磁盘结构与参数"><a href="#磁盘结构与参数" class="headerlink" title="磁盘结构与参数"></a>磁盘结构与参数</h4><p><img src="/images/disk.jpg"></p>
<p><span class="cankao">参考：</span><br><a href="https://www.bilibili.com/video/BV1yU4y1371J?p=17">https://www.bilibili.com/video/BV1yU4y1371J?p=4</a></p>
]]></content>
      <categories>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>软考</tag>
        <tag>计算机组成</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程基础</title>
    <url>/2021/10/23/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码不对噢" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="e8fc9bdbc19ebde0a8ec4aa8b640f409ad8e5b99492e9d4fef20497ef2650309">4630436162ade97ba2718b7d0c4b3b630d823d9e4a4943f517d1b4bc6820f21a078badd6c94d1a5c9e613acd6235da05</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码并回车</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>青龙面板+xdd-plus小白教程</title>
    <url>/2021/10/16/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF-xdd-plus%E5%B0%8F%E7%99%BD%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1-安装宝塔"><a href="#1-安装宝塔" class="headerlink" title="1.安装宝塔"></a>1.安装宝塔</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2-在宝塔面板安装docker"><a href="#2-在宝塔面板安装docker" class="headerlink" title="2.在宝塔面板安装docker"></a>2.在宝塔面板安装docker</h2><h2 id="3-设置docker开机自启"><a href="#3-设置docker开机自启" class="headerlink" title="3.设置docker开机自启"></a>3.设置docker开机自启</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl status docker</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<h2 id="4-拉取青龙面板"><a href="#4-拉取青龙面板" class="headerlink" title="4.拉取青龙面板"></a>4.拉取青龙面板</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull whyour/qinglong:latest</span><br></pre></td></tr></table></figure>

<h2 id="5-创建青龙容器"><a href="#5-创建青龙容器" class="headerlink" title="5.创建青龙容器"></a>5.创建青龙容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -dit \</span><br><span class="line">  -v <span class="variable">$PWD</span>/ql/config:/ql/config \</span><br><span class="line">  -v <span class="variable">$PWD</span>/ql/<span class="built_in">log</span>:/ql/<span class="built_in">log</span> \</span><br><span class="line">  -v <span class="variable">$PWD</span>/ql/db:/ql/db \</span><br><span class="line">  -v <span class="variable">$PWD</span>/ql/repo:/ql/repo \</span><br><span class="line">  -v <span class="variable">$PWD</span>/ql/raw:/ql/raw \</span><br><span class="line">  -v <span class="variable">$PWD</span>/ql/scripts:/ql/scripts \</span><br><span class="line">  -v <span class="variable">$PWD</span>/ql/jbot:/ql/jbot \</span><br><span class="line">  -p 5700:5700 \</span><br><span class="line">  --name qinglong \</span><br><span class="line">  --hostname qinglong \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  whyour/qinglong:latest</span><br></pre></td></tr></table></figure>

<p>ninja可选：<br>  -p 5701:5701 <br>  -v $PWD/ql/ninja:/ql/ninja \</p>
<h2 id="6-放行端口组"><a href="#6-放行端口组" class="headerlink" title="6.放行端口组"></a>6.放行端口组</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=5700/tcp --permanent   <span class="comment">#放通5700/tcp端口</span></span><br><span class="line">firewall-cmd --reload                     <span class="comment">#重新加载防火墙 生效新规则</span></span><br></pre></td></tr></table></figure>

<p>等待一会即可进去青龙面板 （浏览器地址栏 ip地址:端口号）</p>
<h2 id="7-一步安装依赖，先进入青龙容器-名字看自己写的什么"><a href="#7-一步安装依赖，先进入青龙容器-名字看自己写的什么" class="headerlink" title="7.一步安装依赖，先进入青龙容器 名字看自己写的什么"></a>7.一步安装依赖，先进入青龙容器 名字看自己写的什么</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">`docker <span class="built_in">exec</span> -it qinglong bash <span class="comment">#qinglong为容器名根据自己容器修改`</span></span><br></pre></td></tr></table></figure>



<h2 id="8-在ql目录下复制进去运行即可"><a href="#8-在ql目录下复制进去运行即可" class="headerlink" title="8.在ql目录下复制进去运行即可"></a>8.在ql目录下复制进去运行即可</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package_name=<span class="string">&quot;canvas png-js date-fns axios crypto-js ts-md5 tslib @types/node dotenv typescript fs require tslib&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$package_name</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$i</span> <span class="keyword">in</span></span><br><span class="line">        canvas)</span><br><span class="line">            <span class="built_in">cd</span> /ql/scripts</span><br><span class="line">            npm ls <span class="variable">$i</span></span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            npm ls <span class="variable">$i</span> -g</span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>




<h1 id="安装xdd"><a href="#安装xdd" class="headerlink" title="安装xdd"></a>安装xdd</h1><h2 id="1-下载go安装包-，这里我们安装到usr-local目录"><a href="#1-下载go安装包-，这里我们安装到usr-local目录" class="headerlink" title="1.下载go安装包 ，这里我们安装到usr/local目录"></a>1.下载go安装包 ，这里我们安装到usr/local目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span> &amp;&amp; wget https://golang.google.cn/dl/go1.16.7.linux-amd64.tar.gz -O go1.16.7.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="2-解压安装包"><a href="#2-解压安装包" class="headerlink" title="2.解压安装包"></a>2.解压安装包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvzf go1.16.7.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="3-设置环境变量"><a href="#3-设置环境变量" class="headerlink" title="3.设置环境变量"></a>3.设置环境变量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/profile </span><br></pre></td></tr></table></figure>

<p>下面代码复制到最后新起一行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn</span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go</span><br><span class="line"><span class="built_in">export</span> GOPATH=/usr/<span class="built_in">local</span>/go/path</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin:<span class="variable">$GOPATH</span>/bin</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile <span class="comment">##在当前bash环境下读取并执行profile中的命令。</span></span><br></pre></td></tr></table></figure>



<h2 id="4-查看go安装是否完成"><a href="#4-查看go安装是否完成" class="headerlink" title="4.查看go安装是否完成"></a>4.查看go安装是否完成</h2><p>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go env </span><br></pre></td></tr></table></figure>

<p>输出一长串代表没错</p>
<h2 id="5-安装git"><a href="#5-安装git" class="headerlink" title="5.安装git"></a>5.安装git</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span><br><span class="line">rpm -ivh epel-release-latest-7.noarch.rpm</span><br><span class="line">yum install -y git</span><br></pre></td></tr></table></figure>

<h2 id="6-编译安装XDD"><a href="#6-编译安装XDD" class="headerlink" title="6.编译安装XDD"></a>6.编译安装XDD</h2><p>如果之前装过了先备份以下文件，新版解压后直接把文件拖进去<br>.xdd.db(数据文件)<br>config.yaml(配置文件)<br>session.token(QQ机器人登录凭证)<br>reply.php(机器人自定义回复配置)</p>
<h3 id="1-plus版直接用下面命令拉库"><a href="#1-plus版直接用下面命令拉库" class="headerlink" title="1.plus版直接用下面命令拉库"></a>1.plus版直接用下面命令拉库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~ &amp;&amp; git <span class="built_in">clone</span> https://ghproxy.com/https://github.com/764763903a/xdd-plus.git</span><br></pre></td></tr></table></figure>

<h3 id="2-编译xdd"><a href="#2-编译xdd" class="headerlink" title="2.编译xdd"></a>2.编译xdd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> xdd-plus &amp;&amp; go build  </span><br></pre></td></tr></table></figure>

<h3 id="3-赋予权限并运行"><a href="#3-赋予权限并运行" class="headerlink" title="3.赋予权限并运行"></a>3.赋予权限并运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 777 xdd</span><br><span class="line">./xdd</span><br></pre></td></tr></table></figure>

<p>让它跑一会 然后退出 退出命令是 Ctrl ＋ C</p>
<h3 id="4-更改配置文件"><a href="#4-更改配置文件" class="headerlink" title="4.更改配置文件"></a>4.更改配置文件</h3><p>魔改版打开/root/xdd/conf/config.yaml<br>plus版打开/root/xdd-plus/conf/config.yaml<br>这个很重要请认真配置<br>样例文件如下: 所有前面#开头的都是注释掉的，如果要使用请自行删除 ，中文注释就不用删了 删了就出错了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mode: parallel</span><br><span class="line">containers:</span><br><span class="line"></span><br><span class="line">  - address: http://ip:青龙端口</span><br><span class="line">    username: 青龙账号</span><br><span class="line">    password: 青龙密码</span><br><span class="line">    cid: 青龙创建应用可见</span><br><span class="line">    secret: 青龙创建应用可见</span><br><span class="line">    weigth: </span><br><span class="line">    mode: parallel</span><br><span class="line">    <span class="built_in">limit</span>: 9999</span><br><span class="line">    theme: /root/xdd-plus/theme/admin.html <span class="comment">#plus用admin.html自定义主题，支持本地、网络路径</span></span><br><span class="line">    static: ./static <span class="comment">#静态文件 便于自定义二维码页面时，引入css、js等文件</span></span><br><span class="line">    master: <span class="comment">#xdd后台密码</span></span><br><span class="line">    database: </span><br><span class="line">    qywx_key:  <span class="comment">#企业微信推送key</span></span><br><span class="line">    daily_push: <span class="comment">#定时任务</span></span><br><span class="line">    resident: jd_xxxxx <span class="comment">#均衡模式下所有容器共同的账号pin，有多个用&#x27;&amp;&#x27;拼接。不建议填写，后续实现指定账号助力功能。</span></span><br><span class="line">    <span class="comment">#自定义ua</span></span><br><span class="line">    user_agent:</span><br><span class="line">    telegram_bot_token: </span><br><span class="line">    telegram_user_id: </span><br><span class="line">    qquid:  <span class="comment">#接收通知的qq号，管理员QQ号码</span></span><br><span class="line">    qqgid:  <span class="comment">#监听的群</span></span><br><span class="line">    default_priority: 1<span class="comment">#新用户默认优先级</span></span><br><span class="line">    no_ghproxy: <span class="literal">false</span> <span class="comment">#更新资源是否不使用代理 默认false</span></span><br><span class="line">    qbot_public_mode: <span class="literal">true</span>  <span class="comment">#qq机器人群聊模式，默认私聊模式</span></span><br></pre></td></tr></table></figure>



<p>找到/root/xdd-plus/.git/config文件<br>在文件最后一行加上两行代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">       email = xxx@qq.com <span class="comment">#自己的邮箱或者随意</span></span><br><span class="line">       name = 爱的味道 <span class="comment">#随意昵称</span></span><br></pre></td></tr></table></figure>

<p>改好保存</p>
<h3 id="5-再次运行-然后绑定QQ机器人🤖"><a href="#5-再次运行-然后绑定QQ机器人🤖" class="headerlink" title="5.再次运行 然后绑定QQ机器人🤖"></a>5.再次运行 然后绑定QQ机器人🤖</h3><p>cd xdd-plus &amp;&amp; ./xdd</p>
<h3 id="6-挂机静默运行"><a href="#6-挂机静默运行" class="headerlink" title="6.挂机静默运行"></a>6.挂机静默运行</h3><p>nohup ./xdd 1&gt;/dev/null 2&gt;&amp;1 &amp; #AMD64<br>或者./xdd -d</p>
<p>后台地址<a href="http://ip:8080/">http://IP:8080</a> 自己改过端口号的 <a href="http://IP:端口号">http://IP:端口号</a></p>
<p>xdd装完了接下来装其依赖环境<br><a href="http://train2000.top/2021/10/17/xdd%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85/">xdd相关依赖安装 | 筱林同学的blog</a></p>
]]></content>
      <categories>
        <category>青龙面板</category>
      </categories>
      <tags>
        <tag>xdd-plus</tag>
        <tag>青龙</tag>
      </tags>
  </entry>
</search>
